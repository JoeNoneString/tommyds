<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TommyDS</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="tommy.css" rel="stylesheet" type="text/css">
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21967501-2']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tommy Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Introduction"></a>
Introduction</h1>
<p>Tommy is a C library of array, hashtables and tries data structures, designed for high performance and providing an easy to use interface.</p>
<p>It's <b>faster</b> than all the similar libraries like <a href="http://www.canonware.com/rb/">rbtree</a>, <a href="http://judy.sourceforge.net/">judy</a>, <a href="http://code.google.com/p/cpp-btree/">googlebtree</a>, <a href="http://panthema.net/2007/stx-btree/">stxbtree</a>, <a href="http://attractivechaos.awardspace.com/">khash</a>, <a href="http://uthash.sourceforge.net/">uthash</a>, <a href="http://www.nedprod.com/programs/portable/nedtries/">nedtrie</a>, <a href="http://code.google.com/p/judyarray/">judyarray</a>, <a href="http://concurrencykit.org/">concurrencykit</a> and others. Only <a href="https://github.com/sparsehash/sparsehash">googledensehash</a> is a real competitor for Tommy.</p>
<p>The data structures provided are:</p>
<ul>
<li><a class="el" href="tommylist_8h.html#a45d098412d5f0be21113b252caee491b" title="Double linked list type. ">tommy_list</a> - A double linked list.</li>
<li><a class="el" href="tommyarray_8h.html#a0f2ab5f891aee3ba7aae019ac74cb5eb" title="Array container type. ">tommy_array</a>, <a class="el" href="tommyarrayof_8h.html#a265cf9d9d06c31d6835a3a2d4e2b70a8" title="Array container type. ">tommy_arrayof</a> - A linear array. It doesn't fragment the heap.</li>
<li><a class="el" href="tommyarrayblk_8h.html#a773ff562ec3bdc01196b5bb3fdf4adbf" title="Array container type. ">tommy_arrayblk</a>, <a class="el" href="tommyarrayblkof_8h.html#abee2c871ff786fd2d0e8df1496b24e4d" title="Array container type. ">tommy_arrayblkof</a> - A blocked linear array. It doesn't fragment the heap and it minimizes the space occupation.</li>
<li><a class="el" href="tommyhashtbl_8h.html#a506978bdee7fd24f76a0ba7547206513" title="Hashtable container type. ">tommy_hashtable</a> - A fixed size chained hashtable.</li>
<li><a class="el" href="tommyhashdyn_8h.html#a00c8b944d273f38f9eef91417a1e8991" title="Hashtable container type. ">tommy_hashdyn</a> - A dynamic chained hashtable.</li>
<li><a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904" title="Hashtable container type. ">tommy_hashlin</a> - A linear chained hashtable. It doesn't have the problem of the delay when resizing and it doesn't fragment the heap.</li>
<li><a class="el" href="tommytrie_8h.html#a05c17b0ace098768808aa9effcaa9559" title="Trie container type. ">tommy_trie</a> - A trie optimized for cache utilization.</li>
<li><a class="el" href="tommytrieinp_8h.html#aa375bb131f3d221a24774aef08b27a0a" title="Trie container type. ">tommy_trie_inplace</a> - A trie completely inplace.</li>
<li><a class="el" href="tommytree_8h.html#adc6c9a39a18bbcffc29f045e15206b65" title="Tree container type. ">tommy_tree</a> - A tree to keep elements in order.</li>
</ul>
<p>The most interesting are <a class="el" href="tommyarray_8h.html#a0f2ab5f891aee3ba7aae019ac74cb5eb" title="Array container type. ">tommy_array</a>, <a class="el" href="tommyhashdyn_8h.html#a00c8b944d273f38f9eef91417a1e8991" title="Hashtable container type. ">tommy_hashdyn</a>, <a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904" title="Hashtable container type. ">tommy_hashlin</a>, <a class="el" href="tommytrie_8h.html#a05c17b0ace098768808aa9effcaa9559" title="Trie container type. ">tommy_trie</a> and <a class="el" href="tommytrieinp_8h.html#aa375bb131f3d221a24774aef08b27a0a" title="Trie container type. ">tommy_trie_inplace</a>.</p>
<p>The official site of TommyDS is <a href="http://www.tommyds.it/">http://www.tommyds.it/</a>,</p>
<h1><a class="anchor" id="Use"></a>
Use</h1>
<p>All the Tommy containers are used to store pointers to generic objects, associated to an integer value, that could be a key or a hash value.</p>
<p>They are semantically equivalent at the C++ <a href="http://www.cplusplus.com/reference/map/multimap/">multimap&lt;unsigned,void*&gt;</a> and <a href="http://www.cplusplus.com/reference/unordered_map/unordered_multimap/">unordered_multimap&lt;unsigned,void*&gt;</a>.</p>
<p>An object, to be inserted in a container, should contain a node of type <a class="el" href="tommytypes_8h.html#a56a5b6211015e83fd69c4f990ac5612b" title="Data structure node. ">tommy_node</a>. Inside this node is present a pointer to the object itself in the <a class="el" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f" title="Pointer to the object containing the node. ">tommy_node::data</a> field, the key used to identify the object in the <a class="el" href="structtommy__node__struct.html#a124aaecab9e5d3d1fbb9239dac779d23" title="Key used to store the node. ">tommy_node::key</a> field, and other fields used by the containers.</p>
<p>This is a typical object declaration: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>object {</div>
<div class="line">    <span class="comment">// other fields</span></div>
<div class="line">    <a class="code" href="structtommy__node__struct.html">tommy_node</a> node;</div>
<div class="line">};</div>
</div><!-- fragment --><p>To insert an object in a container, you have to provide the address of the embedded node, the address of the object and the value of the key. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> key_to_insert = 1;</div>
<div class="line"><span class="keyword">struct </span>object* obj = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="keywordtype">object</span>));</div>
<div class="line">...</div>
<div class="line">tommy_trie_insert(..., &amp;obj-&gt;node, obj, key_to_insert);</div>
</div><!-- fragment --><p>To search an object you have to provide the key and call the search function. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> key_to_find = 1;</div>
<div class="line"><span class="keyword">struct </span>object* obj = <a class="code" href="tommytrie_8h.html#a1170abedabdc9d919db8728d238c50db">tommy_trie_search</a>(..., key_to_find);</div>
<div class="line"><span class="keywordflow">if</span> (obj) {</div>
<div class="line">  <span class="comment">// found</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>To access all the objects with the same keys you have to iterate over the bucket assigned at the specified key. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> key_to_find = 1;</div>
<div class="line"><a class="code" href="structtommy__node__struct.html">tommy_trie_node</a>* i = <a class="code" href="tommytrie_8h.html#a0ab11f26139ff2a1d405ace4a1af0e6a">tommy_trie_bucket</a>(..., key_to_find);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">while</span> (i) {</div>
<div class="line">    <span class="keyword">struct </span>object* obj = i-&gt;<a class="code" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f">data</a>; <span class="comment">// gets the object pointer</span></div>
<div class="line"></div>
<div class="line">    printf(<span class="stringliteral">&quot;%d\n&quot;</span>, obj-&gt;value); <span class="comment">// process the object</span></div>
<div class="line"></div>
<div class="line">    i = i-&gt;<a class="code" href="structtommy__node__struct.html#a53338f3f5366866598ed9ac7e46e64a2">next</a>; <span class="comment">// goes to the next element</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>To remove an object you have to provide the key and call the remove function. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> key_to_remove = 1;</div>
<div class="line"><span class="keyword">struct </span>object* obj = <a class="code" href="tommytrie_8h.html#a47ed46af4087783c351172280d03ed6b">tommy_trie_remove</a>(..., key_to_remove);</div>
<div class="line"><span class="keywordflow">if</span> (obj) {</div>
<div class="line">    <span class="comment">// found</span></div>
<div class="line">    free(obj); <span class="comment">// frees the object allocated memory</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Dealing with hashtables, instead of the key, you have to provide the hash value of the object, and a compare function able to differentiate objects with the same hash value. To compute the hash value, you can use the generic <a class="el" href="tommyhash_8h.html#ab020046d7799cda5b440bd49b4e282d8" title="Hash function with a 32 bits result. ">tommy_hash_u32()</a> function, or the specialized integer hash function <a class="el" href="tommyhash_8h.html#aea9c8438064a941d13e6f5462b5bff71" title="Integer reversible hash function for 32 bits. ">tommy_inthash_u32()</a>.</p>
<h1><a class="anchor" id="Features"></a>
Features</h1>
<p>Tommy is fast and easy to use.</p>
<p>Tommy is portable to all platforms and operating systems.</p>
<p>Tommy containers support multiple elements with the same key.</p>
<p>Tommy containers keep the original insertion order of elements with equal keys.</p>
<p>Tommy is released with the <a class="el" href="license.html">2-clause BSD license</a>.</p>
<p>See the <a class="el" href="design.html">Tommy Design</a> page for more details and limitations.</p>
<h1><a class="anchor" id="Performance"></a>
Performance</h1>
<p>Here you can see some timings comparing with other notable implementations. The <em>Hit</em> graph shows the time required for searching random objects with a key. The <em>Change</em> graph shows the time required for searching, removing and reinsert random objects with a different key value.</p>
<p>Times are expressed in nanoseconds for each element, and <b>lower is better</b>.</p>
<p>To have some reference numbers, you can check <a href="https://gist.github.com/jboner/2841832">Latency numbers every programmer should know</a>.</p>
<p>A complete analysis is available in the <a class="el" href="benchmark.html">Tommy Benchmarks</a> page.</p>
<div class="image">
<img src="def/img_random_hit.png" />
</div>
<div class="image">
<img src="def/img_random_change.png" />
</div>
 </div></div><!-- contents -->
</body>
</html>
