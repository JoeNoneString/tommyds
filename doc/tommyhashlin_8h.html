<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TommyDS</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="tommy.css" rel="stylesheet" type="text/css">
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21967501-2']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_108ac671c162006792b32851db85b9de.html">tommyds</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tommyhashlin.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Linear chained hashtable.  
<a href="#details">More...</a></p>

<p><a href="tommyhashlin_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin_struct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashtable container type.  <a href="structtommy__hashlin__struct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a85850646f4dc979b7b213d8c58c13542"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="tommytypes_8h.html#a56a5b6211015e83fd69c4f990ac5612b">tommy_node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#a85850646f4dc979b7b213d8c58c13542">tommy_hashlin_node</a></td></tr>
<tr class="memdesc:a85850646f4dc979b7b213d8c58c13542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashtable node.  <a href="#a85850646f4dc979b7b213d8c58c13542">More...</a><br /></td></tr>
<tr class="separator:a85850646f4dc979b7b213d8c58c13542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad910f88af8bcd013a8e3cd30d528b904"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin_struct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a></td></tr>
<tr class="memdesc:ad910f88af8bcd013a8e3cd30d528b904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashtable container type.  <a href="#ad910f88af8bcd013a8e3cd30d528b904">More...</a><br /></td></tr>
<tr class="separator:ad910f88af8bcd013a8e3cd30d528b904"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a639fc97c94668bac0424691c6a5094cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#a639fc97c94668bac0424691c6a5094cb">tommy_hashlin_init</a> (<a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *hashlin)</td></tr>
<tr class="memdesc:a639fc97c94668bac0424691c6a5094cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the hashtable.  <a href="#a639fc97c94668bac0424691c6a5094cb">More...</a><br /></td></tr>
<tr class="separator:a639fc97c94668bac0424691c6a5094cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49c4514766dab75ad2157fcd39d1f1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#af49c4514766dab75ad2157fcd39d1f1f">tommy_hashlin_done</a> (<a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *hashlin)</td></tr>
<tr class="memdesc:af49c4514766dab75ad2157fcd39d1f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitializes the hashtable.  <a href="#af49c4514766dab75ad2157fcd39d1f1f">More...</a><br /></td></tr>
<tr class="separator:af49c4514766dab75ad2157fcd39d1f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51e1c6766cac604ed1545b5649ff957"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#ad51e1c6766cac604ed1545b5649ff957">tommy_hashlin_insert</a> (<a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *hashlin, <a class="el" href="tommyhashlin_8h.html#a85850646f4dc979b7b213d8c58c13542">tommy_hashlin_node</a> *node, void *data, <a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a> hash)</td></tr>
<tr class="memdesc:ad51e1c6766cac604ed1545b5649ff957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element in the hashtable.  <a href="#ad51e1c6766cac604ed1545b5649ff957">More...</a><br /></td></tr>
<tr class="separator:ad51e1c6766cac604ed1545b5649ff957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598c4204c7478fa2e0601c16f58ebc91"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#a598c4204c7478fa2e0601c16f58ebc91">tommy_hashlin_remove</a> (<a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *hashlin, <a class="el" href="tommytypes_8h.html#a9008971cd09a3f9c4f9da45cffb4627d">tommy_search_func</a> *cmp, const void *cmp_arg, <a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a> hash)</td></tr>
<tr class="memdesc:a598c4204c7478fa2e0601c16f58ebc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches and removes an element from the hashtable.  <a href="#a598c4204c7478fa2e0601c16f58ebc91">More...</a><br /></td></tr>
<tr class="separator:a598c4204c7478fa2e0601c16f58ebc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2841df6043a5de8b4e47451748d4cfb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tommyhashlin_8h.html#a85850646f4dc979b7b213d8c58c13542">tommy_hashlin_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#a2841df6043a5de8b4e47451748d4cfb2">tommy_hashlin_bucket</a> (<a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *hashlin, <a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a> hash)</td></tr>
<tr class="memdesc:a2841df6043a5de8b4e47451748d4cfb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bucket of the specified hash.  <a href="#a2841df6043a5de8b4e47451748d4cfb2">More...</a><br /></td></tr>
<tr class="separator:a2841df6043a5de8b4e47451748d4cfb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84509ea942686e6140361cc4bdd14522"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#a84509ea942686e6140361cc4bdd14522">tommy_hashlin_search</a> (<a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *hashlin, <a class="el" href="tommytypes_8h.html#a9008971cd09a3f9c4f9da45cffb4627d">tommy_search_func</a> *cmp, const void *cmp_arg, <a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a> hash)</td></tr>
<tr class="memdesc:a84509ea942686e6140361cc4bdd14522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches an element in the hashtable.  <a href="#a84509ea942686e6140361cc4bdd14522">More...</a><br /></td></tr>
<tr class="separator:a84509ea942686e6140361cc4bdd14522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc35c9f3213033f7e814be4bc2a2aef6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#afc35c9f3213033f7e814be4bc2a2aef6">tommy_hashlin_remove_existing</a> (<a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *hashlin, <a class="el" href="tommyhashlin_8h.html#a85850646f4dc979b7b213d8c58c13542">tommy_hashlin_node</a> *node)</td></tr>
<tr class="memdesc:afc35c9f3213033f7e814be4bc2a2aef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an element from the hashtable.  <a href="#afc35c9f3213033f7e814be4bc2a2aef6">More...</a><br /></td></tr>
<tr class="separator:afc35c9f3213033f7e814be4bc2a2aef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce857922fa2db3c21de565731cb10b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#afce857922fa2db3c21de565731cb10b6">tommy_hashlin_foreach</a> (<a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *hashlin, <a class="el" href="tommytypes_8h.html#a8caf78c4fb7706a85093f99598d61b5d">tommy_foreach_func</a> *func)</td></tr>
<tr class="memdesc:afce857922fa2db3c21de565731cb10b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the specified function for each element in the hashtable.  <a href="#afce857922fa2db3c21de565731cb10b6">More...</a><br /></td></tr>
<tr class="separator:afce857922fa2db3c21de565731cb10b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f581666a69600fcc9e787173e18f0e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#a5f581666a69600fcc9e787173e18f0e1">tommy_hashlin_foreach_arg</a> (<a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *hashlin, <a class="el" href="tommytypes_8h.html#ae0aea577584dfbe750f078b3801d0ee6">tommy_foreach_arg_func</a> *func, void *arg)</td></tr>
<tr class="memdesc:a5f581666a69600fcc9e787173e18f0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the specified function with an argument for each element in the hashtable.  <a href="#a5f581666a69600fcc9e787173e18f0e1">More...</a><br /></td></tr>
<tr class="separator:a5f581666a69600fcc9e787173e18f0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ca6bf8a7db3df51eb6e354d5302447"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tommytypes_8h.html#a802a296e9903e3bc098432b9bdad03ab">tommy_count_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#a74ca6bf8a7db3df51eb6e354d5302447">tommy_hashlin_count</a> (<a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *hashlin)</td></tr>
<tr class="memdesc:a74ca6bf8a7db3df51eb6e354d5302447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of elements.  <a href="#a74ca6bf8a7db3df51eb6e354d5302447">More...</a><br /></td></tr>
<tr class="separator:a74ca6bf8a7db3df51eb6e354d5302447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bd9d60d6f2039230aefefaaa8a8c1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tommytypes_8h.html#a32aad870b975610a257f9c2d14b0825e">tommy_size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashlin_8h.html#a35bd9d60d6f2039230aefefaaa8a8c1b">tommy_hashlin_memory_usage</a> (<a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *hashlin)</td></tr>
<tr class="memdesc:a35bd9d60d6f2039230aefefaaa8a8c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of allocated memory.  <a href="#a35bd9d60d6f2039230aefefaaa8a8c1b">More...</a><br /></td></tr>
<tr class="separator:a35bd9d60d6f2039230aefefaaa8a8c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Linear chained hashtable. </p>
<p>This hashtable resizes dynamically and progressively using a variation of the linear hashing algorithm described in <a href="http://en.wikipedia.org/wiki/Linear_hashing">http://en.wikipedia.org/wiki/Linear_hashing</a></p>
<p>It starts with the minimal size of 16 buckets, it doubles the size then it reaches a load factor greater than 0.5 and it halves the size with a load factor lower than 0.125.</p>
<p>The progressive resize is good for real-time and interactive applications as it makes insert and delete operations taking always the same time.</p>
<p>For resizing it's used a dynamic array that supports access to not contigous segments. In this way we only allocate additional table segments on the heap, without freeing the previous table, and then not increasing the heap fragmentation.</p>
<p>The resize takes place inside <a class="el" href="tommyhashlin_8h.html#ad51e1c6766cac604ed1545b5649ff957" title="Inserts an element in the hashtable. ">tommy_hashlin_insert()</a> and <a class="el" href="tommyhashlin_8h.html#a598c4204c7478fa2e0601c16f58ebc91" title="Searches and removes an element from the hashtable. ">tommy_hashlin_remove()</a>. No resize is done in the <a class="el" href="tommyhashlin_8h.html#a84509ea942686e6140361cc4bdd14522" title="Searches an element in the hashtable. ">tommy_hashlin_search()</a> operation.</p>
<p>To initialize the hashtable you have to call <a class="el" href="tommyhashlin_8h.html#a639fc97c94668bac0424691c6a5094cb" title="Initializes the hashtable. ">tommy_hashlin_init()</a>.</p>
<div class="fragment"><div class="line">tommy_hashslin hashlin;</div>
<div class="line"></div>
<div class="line"><a class="code" href="tommyhashlin_8h.html#a639fc97c94668bac0424691c6a5094cb">tommy_hashlin_init</a>(&amp;hashlin);</div>
</div><!-- fragment --><p>To insert elements in the hashtable you have to call <a class="el" href="tommyhashlin_8h.html#ad51e1c6766cac604ed1545b5649ff957" title="Inserts an element in the hashtable. ">tommy_hashlin_insert()</a> for each element. In the insertion call you have to specify the address of the node, the address of the object, and the hash value of the key to use. The address of the object is used to initialize the <a class="el" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f" title="Pointer to the object containing the node. ">tommy_node::data</a> field of the node, and the hash to initialize the <a class="el" href="structtommy__node__struct.html#a124aaecab9e5d3d1fbb9239dac779d23" title="Key used to store the node. ">tommy_node::key</a> field.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>object {</div>
<div class="line">    <span class="keywordtype">int</span> value;</div>
<div class="line">    <span class="comment">// other fields</span></div>
<div class="line">    <a class="code" href="structtommy__node__struct.html">tommy_node</a> node;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>object* obj = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="keywordtype">object</span>)); <span class="comment">// creates the object</span></div>
<div class="line"></div>
<div class="line">obj-&gt;value = ...; <span class="comment">// initializes the object</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="tommyhashlin_8h.html#ad51e1c6766cac604ed1545b5649ff957">tommy_hashlin_insert</a>(&amp;hashlin, &amp;obj-&gt;node, obj, <a class="code" href="tommyhash_8h.html#aea9c8438064a941d13e6f5462b5bff71">tommy_inthash_u32</a>(obj-&gt;value)); <span class="comment">// inserts the object</span></div>
</div><!-- fragment --><p>To find and element in the hashtable you have to call <a class="el" href="tommyhashtbl_8h.html#a9a2455500c2ed927005ca7d222aa60ff" title="Searches an element in the hashtable. ">tommy_hashtable_search()</a> providing a comparison function, its argument, and the hash of the key to search.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> compare(<span class="keyword">const</span> <span class="keywordtype">void</span>* arg, <span class="keyword">const</span> <span class="keywordtype">void</span>* obj)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> *(<span class="keyword">const</span> <span class="keywordtype">int</span>*)arg != ((<span class="keyword">const</span> <span class="keyword">struct</span> <span class="keywordtype">object</span>*)obj)-&gt;value;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> value_to_find = 1;</div>
<div class="line"><span class="keyword">struct </span>object* obj = <a class="code" href="tommyhashlin_8h.html#a84509ea942686e6140361cc4bdd14522">tommy_hashlin_search</a>(&amp;hashlin, compare, &amp;value_to_find, <a class="code" href="tommyhash_8h.html#aea9c8438064a941d13e6f5462b5bff71">tommy_inthash_u32</a>(value_to_find));</div>
<div class="line"><span class="keywordflow">if</span> (!obj) {</div>
<div class="line">    <span class="comment">// not found</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// found</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>To iterate over all the elements in the hashtable with the same key, you have to use <a class="el" href="tommyhashlin_8h.html#a2841df6043a5de8b4e47451748d4cfb2" title="Gets the bucket of the specified hash. ">tommy_hashlin_bucket()</a> and follow the <a class="el" href="structtommy__node__struct.html#a53338f3f5366866598ed9ac7e46e64a2" title="Next node. ">tommy_node::next</a> pointer until NULL. You have also to check explicitely for the key, as the bucket may contains different keys.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> value_to_find = 1;</div>
<div class="line"><a class="code" href="structtommy__node__struct.html">tommy_node</a>* i = <a class="code" href="tommyhashlin_8h.html#a2841df6043a5de8b4e47451748d4cfb2">tommy_hashlin_bucket</a>(&amp;hashlin, <a class="code" href="tommyhash_8h.html#aea9c8438064a941d13e6f5462b5bff71">tommy_inthash_u32</a>(value_to_find));</div>
<div class="line"><span class="keywordflow">while</span> (i) {</div>
<div class="line">    <span class="keyword">struct </span>object* obj = i-&gt;<a class="code" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f">data</a>; <span class="comment">// gets the object pointer</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (obj-&gt;value == value_to_find) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;%d\n&quot;</span>, obj-&gt;value); <span class="comment">// process the object</span></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    i = i-&gt;<a class="code" href="structtommy__node__struct.html#a53338f3f5366866598ed9ac7e46e64a2">next</a>; <span class="comment">// goes to the next element</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>To remove an element from the hashtable you have to call <a class="el" href="tommyhashlin_8h.html#a598c4204c7478fa2e0601c16f58ebc91" title="Searches and removes an element from the hashtable. ">tommy_hashlin_remove()</a> providing a comparison function, its argument, and the hash of the key to search and remove.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>object* obj = <a class="code" href="tommyhashlin_8h.html#a598c4204c7478fa2e0601c16f58ebc91">tommy_hashlin_remove</a>(&amp;hashlin, compare, &amp;value_to_remove, <a class="code" href="tommyhash_8h.html#aea9c8438064a941d13e6f5462b5bff71">tommy_inthash_u32</a>(value_to_remove));</div>
<div class="line"><span class="keywordflow">if</span> (obj) {</div>
<div class="line">    free(obj); <span class="comment">// frees the object allocated memory</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>To destroy the hashtable you have to remove all the elements, and deinitialize the hashtable calling <a class="el" href="tommyhashlin_8h.html#af49c4514766dab75ad2157fcd39d1f1f" title="Deinitializes the hashtable. ">tommy_hashlin_done()</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="tommyhashlin_8h.html#af49c4514766dab75ad2157fcd39d1f1f">tommy_hashlin_done</a>(&amp;hashlin);</div>
</div><!-- fragment --><p>If you need to iterate over all the elements in the hashtable, you can use <a class="el" href="tommyhashlin_8h.html#afce857922fa2db3c21de565731cb10b6" title="Calls the specified function for each element in the hashtable. ">tommy_hashlin_foreach()</a> or <a class="el" href="tommyhashlin_8h.html#a5f581666a69600fcc9e787173e18f0e1" title="Calls the specified function with an argument for each element in the hashtable. ">tommy_hashlin_foreach_arg()</a>. If you need a more precise control with a real iteration, you have to insert all the elements also in a <a class="el" href="tommylist_8h.html#a45d098412d5f0be21113b252caee491b" title="Double linked list type. ">tommy_list</a>, and use the list to iterate. See the <a class="el" href="multiindex.html">Tommy Multi Indexing</a> example for more detail. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a85850646f4dc979b7b213d8c58c13542"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="tommytypes_8h.html#a56a5b6211015e83fd69c4f990ac5612b">tommy_node</a> <a class="el" href="tommyhashlin_8h.html#a85850646f4dc979b7b213d8c58c13542">tommy_hashlin_node</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashtable node. </p>
<p>This is the node that you have to include inside your objects. </p>

</div>
</div>
<a class="anchor" id="ad910f88af8bcd013a8e3cd30d528b904"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structtommy__hashlin__struct.html">tommy_hashlin_struct</a>  <a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashtable container type. </p>
<dl class="section note"><dt>Note</dt><dd>Don't use internal fields directly, but access the container only using functions. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a639fc97c94668bac0424691c6a5094cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tommy_hashlin_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *&#160;</td>
          <td class="paramname"><em>hashlin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the hashtable. </p>

</div>
</div>
<a class="anchor" id="af49c4514766dab75ad2157fcd39d1f1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tommy_hashlin_done </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *&#160;</td>
          <td class="paramname"><em>hashlin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deinitializes the hashtable. </p>
<p>You can call this function with elements still contained, but such elements are not going to be freed by this call. </p>

</div>
</div>
<a class="anchor" id="ad51e1c6766cac604ed1545b5649ff957"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tommy_hashlin_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *&#160;</td>
          <td class="paramname"><em>hashlin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommyhashlin_8h.html#a85850646f4dc979b7b213d8c58c13542">tommy_hashlin_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a>&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts an element in the hashtable. </p>

</div>
</div>
<a class="anchor" id="a598c4204c7478fa2e0601c16f58ebc91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tommy_hashlin_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *&#160;</td>
          <td class="paramname"><em>hashlin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommytypes_8h.html#a9008971cd09a3f9c4f9da45cffb4627d">tommy_search_func</a> *&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cmp_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a>&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches and removes an element from the hashtable. </p>
<p>You have to provide a compare function and the hash of the element you want to remove. If the element is not found, 0 is returned. If more equal elements are present, the first one is removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmp</td><td>Compare function called with cmp_arg as first argument and with the element to compare as a second one. The function should return 0 for equal elements, anything other for different elements. </td></tr>
    <tr><td class="paramname">cmp_arg</td><td>Compare argument passed as first argument of the compare function. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash of the element to find and remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The removed element, or 0 if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a2841df6043a5de8b4e47451748d4cfb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tommyhashlin_8h.html#a85850646f4dc979b7b213d8c58c13542">tommy_hashlin_node</a>* tommy_hashlin_bucket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *&#160;</td>
          <td class="paramname"><em>hashlin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a>&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the bucket of the specified hash. </p>
<p>The bucket is guaranteed to contain ALL the elements with the specified hash, but it can contain also others. You can access elements in the bucket following the ::next pointer until 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>Hash of the element to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The head of the bucket, or 0 if empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a84509ea942686e6140361cc4bdd14522"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tommy_hashlin_search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *&#160;</td>
          <td class="paramname"><em>hashlin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommytypes_8h.html#a9008971cd09a3f9c4f9da45cffb4627d">tommy_search_func</a> *&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cmp_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a>&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches an element in the hashtable. </p>
<p>You have to provide a compare function and the hash of the element you want to find. If more equal elements are present, the first one is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmp</td><td>Compare function called with cmp_arg as first argument and with the element to compare as a second one. The function should return 0 for equal elements, anything other for different elements. </td></tr>
    <tr><td class="paramname">cmp_arg</td><td>Compare argument passed as first argument of the compare function. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash of the element to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first element found, or 0 if none. </dd></dl>

</div>
</div>
<a class="anchor" id="afc35c9f3213033f7e814be4bc2a2aef6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tommy_hashlin_remove_existing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *&#160;</td>
          <td class="paramname"><em>hashlin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommyhashlin_8h.html#a85850646f4dc979b7b213d8c58c13542">tommy_hashlin_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an element from the hashtable. </p>
<p>You must already have the address of the element to remove. </p><dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f" title="Pointer to the object containing the node. ">tommy_node::data</a> field of the node removed. </dd></dl>

</div>
</div>
<a class="anchor" id="afce857922fa2db3c21de565731cb10b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tommy_hashlin_foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *&#160;</td>
          <td class="paramname"><em>hashlin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommytypes_8h.html#a8caf78c4fb7706a85093f99598d61b5d">tommy_foreach_func</a> *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the specified function for each element in the hashtable. </p>
<p>You cannot add or remove elements from the inside of the callback, but can use it to deallocate them.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;tommy_hashlin hashlin;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;// initializes the hashtable</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;tommy_hashlin_init(&amp;hashlin);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;...</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;// creates an object</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;struct object* obj = malloc(sizeof(struct object));</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;...</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;// insert it in the hashtable</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;tommy_hashlin_insert(&amp;hashlin, &amp;obj-&gt;node, obj, tommy_inthash_u32(obj-&gt;value));</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;...</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;// deallocates all the objects iterating the hashtable</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;tommy_hashlin_foreach(&amp;hashlin, free);</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;// deallocates the hashtable</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;tommy_hashlin_done(&amp;hashlin);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a5f581666a69600fcc9e787173e18f0e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tommy_hashlin_foreach_arg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *&#160;</td>
          <td class="paramname"><em>hashlin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommytypes_8h.html#ae0aea577584dfbe750f078b3801d0ee6">tommy_foreach_arg_func</a> *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the specified function with an argument for each element in the hashtable. </p>

</div>
</div>
<a class="anchor" id="a74ca6bf8a7db3df51eb6e354d5302447"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tommytypes_8h.html#a802a296e9903e3bc098432b9bdad03ab">tommy_count_t</a> tommy_hashlin_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *&#160;</td>
          <td class="paramname"><em>hashlin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of elements. </p>

</div>
</div>
<a class="anchor" id="a35bd9d60d6f2039230aefefaaa8a8c1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tommytypes_8h.html#a32aad870b975610a257f9c2d14b0825e">tommy_size_t</a> tommy_hashlin_memory_usage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904">tommy_hashlin</a> *&#160;</td>
          <td class="paramname"><em>hashlin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of allocated memory. </p>
<p>It includes the size of the <a class="el" href="tommyhashlin_8h.html#a85850646f4dc979b7b213d8c58c13542" title="Hashtable node. ">tommy_hashlin_node</a> of the stored elements. </p>

</div>
</div>
</div><!-- contents -->
</body>
</html>
